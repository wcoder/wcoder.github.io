<!DOCTYPE html> <html prefix="og: http://ogp.me/ns#" lang="ru"> <head> <meta charset="utf-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> <title>Многопоточность в Android. Все что вам нужно знать. Часть 1 - Введение - YP Tech Notes</title> <meta name="description" content="Каждый Android разработчик, в тот или иной момент сталкивается с необходимостью иметь дело с потоками в своем приложении." /> <meta name="keywords" content="многопоточность, android, перевод" /> <meta name="author" content="Yauheni Pakala"> <meta property="og:title" content="Многопоточность в Android. Все что вам нужно знать. Часть 1 - Введение - YP Tech Notes" /> <meta property="og:description" content="Каждый Android разработчик, в тот или иной момент сталкивается с необходимостью иметь дело с потоками в своем приложении." /> <meta property="og:url" content="https://wcoder.github.io/notes/android-threading-all-you-need-to-know-part1" /> <meta property="og:site_name" content="YP Tech Notes" /> <meta property="og:locale" content="ru_RU" /> <meta property="og:type" content="article" /> <meta property="article:author" content="Yauheni Pakala" /> <meta property="article:published_time" content="2017-08-13T11:40:00+03:00" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:creator" content="@yauhenipakala" /> <meta name='yandex-verification' content='7cd440e16ce6e1c3' /> <link rel="icon" type="image/x-icon" href="/images/favicon.ico" /> <link rel="stylesheet" href="/css/main.css" /> <link rel="stylesheet" href="/css/github.min.css" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="YP Tech Notes" /> <meta name="apple-mobile-web-app-title" content="YP Tech Notes" /> <meta name="theme-color" content="#333" /> <meta name="msapplication-navbutton-color" content="#333" /> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /> <meta name="msapplication-starturl" content="/" /> <link rel="manifest" href="/api/manifest.json" /> <link rel="canonical" href="https://wcoder.github.io/notes/android-threading-all-you-need-to-know-part1" /> <link rel="alternate" type="application/atom+xml" title="YP Tech Notes" href="https://wcoder.github.io/atom.xml" /> </head> <body> <header class="site-header"><div class="wrapper"> <a class="site-title" href="/" title="Перейти на главную">Tech Notes</a> <nav class="site-nav"> <a href="#" class="menu-icon" title="Развернуть меню"> <svg xmlns="http://www.w3.org/2000/svg" height="29" viewbox="0 0 48 48" width="48"><path d="M0 0h48v48h-48z" fill="none"></path><path d="M6 36h36v-4h-36v4zm0-10h36v-4h-36v4zm0-14v4h36v-4h-36z"></path> </svg> </a><div class="trigger"> <a class="page-link" href="https://ypakala.com/">Об авторе</a> <a class="page-link" href="/archive/">Архив</a> <a class="page-link" href="/search/">Поиск</a> <a class="page-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
</div></nav>
</div></header><div class="page-content"><div class="wrapper"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"><h1 class="post-title" itemprop="name headline">Многопоточность в Android. Все что вам нужно знать. Часть 1 - Введение</h1>
<p class="post-meta"> <time datetime="2017-08-13T11:40:00+03:00" itemprop="datePublished">13.08.2017 в 11:40</time></p></header><div class="post-content" itemprop="articleBody">
<p>Каждый Android разработчик, в тот или иной момент сталкивается с необходимостью иметь дело с потоками в своем приложении.</p>
<p>Когда приложение запускается, оно создает первый поток выполнения, известный как основной поток или main thread. Основной поток отвечает за отправку событий в соответствующие виджеты пользовательского интерфейса, а также связь с компонентами из набора инструментов Android UI.</p>
<p>Чтобы ваше приложение сохраняло отзывчивость, важно избегать использования основного потока для выполнения любой операции, которая может привести к его блокировке.</p>
<p>Сетевые операции и обращения к базе данных, а также загрузка определенных компонентов, являются типичными примерами операций, которые не следует выполнять в основном потоке. Когда они вызваны в главном потоке, они вызваны синхронно, что означает, что пользовательский интерфейс не будет ни на что реагировать до завершения операции. По этой причине, они обычно выполняются в отдельных потоках, что позволяет избежать блокировки пользовательского интерфейса во время выполнения (т. е. они выполняются асинхронно из UI).</p>
<p>Android предоставляет множество способов создания и управления потоками, и множество сторонних библиотек, которые делают управление потоками гораздо более приятным.</p>
<p><img src="https://uploads.toptal.io/blog/image/122375/toptal-blog-image-1489079683857-fb445c27f8f0fe4d4a94d4731b1d669e.jpg" alt="Многозадачность в Android"></p>
<p>В этой статье вы узнаете о некоторых распространенных сценариях в Android разработке, где многопоточность становится важной, и некоторые простые решения, которые могут быть применены к этим сценариям, и многое другое.</p>
<h2 id="многозадачность-в-android">Многозадачность в Android</h2>
<p>В Android вы можете классифицировать все компоненты потоков на две основные категории:</p>
<ol> <li><p>Потоки связанные с активностью / фрагментом. Эти потоки привязаны к жизненному циклу активности / фрагмента и завершаются сразу после их уничтожения.</p></li> <li><p>Потоки не связанные с активностью / фрагментом. Эти потоки могут продолжать работать за пределами жизни активности / фрагмента (если есть), из которых они были созданы.</p></li> </ol> <h3 id="компоненты-многопоточности-которые-присоединяются-к-активности--фрагменту">Компоненты многопоточности, которые присоединяются к активности / фрагменту</h3> <h4 id="asynctask">AsyncTask</h4>
<p><code>AsyncTask</code> это наиболее основной Android компонент для организации потоков. Он прост в использовании и может быть хорошей основой для вашего сценария.</p>
<p>Пример использования:</p>
<pre><code class="language-java">public class ExampleActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		new MyTask().execute(url);
	}

	private class MyTask extends AsyncTask&lt;String, Void, String&gt; {

		@Override
		protected String doInBackground(String... params) {
			String url = params[0];
			return doSomeWork(url);
		}

		@Override
		protected void onPostExecute(String result) {
			super.onPostExecute(result);
			// что-то делаем с результатом
		}
	}
}
</code></pre>
<p>Однако, <code>AsyncTask</code> не подойдет, если вам нужен отложенный запуск задачи, после завершения работы вашей активности / фрагмента. Стоит отметить, что даже такая простая вещь, как вращение экрана может вызвать уничтожение активности.</p>
<h4 id="загрузчики">Загрузчики</h4>
<p>Загрузчики могут решить проблемы, упомянутые выше. Загрузчик автоматически останавливается, когда уничтожается активность и перезапускает себя, после пересоздания активности.</p>
<p>В основном есть два типа загрузчиков: <code>AsyncTaskLoader</code> и <code>CursorLoader</code>. О загрузчике <code>CursorLoader</code> вы узнаете далее в этой статье.</p>
<p><code>AsyncTaskLoader</code> похож на <code>AsyncTask</code>, но немного сложнее.</p>
<p>Пример использования:</p>
<pre><code class="language-java">public class ExampleActivity extends Activity{

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		getLoaderManager().initLoader(1, null, new MyLoaderCallbacks());
	}

	private class MyLoaderCallbacks implements LoaderManager.LoaderCallbacks {

		@Override
		public Loader onCreateLoader(int id, Bundle args) {
			return new MyLoader(ExampleActivity.this);
		}

		@Override
		public void onLoadFinished(Loader loader, Object data) {

		}

		@Override
		public void onLoaderReset(Loader loader) {

		}
	}

	private class MyLoader extends AsyncTaskLoader {

		public MyLoader(Context context) {
			super(context);
		}

		@Override
		public Object loadInBackground() {
			return someWorkToDo();
		}

	}
}
</code></pre>
<h3 id="компоненты-многопоточности-которые-не-присоединяются-к-активности--фрагменту">Компоненты многопоточности, которые не присоединяются к активности / фрагменту</h3> <h4 id="service">Service</h4>
<p><code>Service</code> это компонент, который полезен для выполнения длинных (или потенциально длительных) операций без какого-либо пользовательского интерфейса.</p>
<p><code>Service</code> работает в основном потоке своего процесса; не создает свой собственный поток и не запускается в отдельном процессе, если вы это не указали.</p>
<p>Пример использования:</p>
<pre><code class="language-java">public class ExampleService extends Service {

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		doSomeLongProccesingWork();
		stopSelf();

		return START_NOT_STICKY;
	}

	@Nullable
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}
}
</code></pre>
<p>Используя <code>Service</code> вы обязаны остановить его, когда его работа будет завершена, вызвав методы <code>stopSelf()</code> или <code>stopService()</code>.</p>
<h4 id="intentservice">IntentService</h4>
<p><code>IntentService</code> работает в отдельном потоке и автоматически останавливается после завершения работы.</p>
<p><code>IntentService</code> обычно используется для коротких задач, которые не обязательно должны быть привязаны к какому-либо пользовательскому интерфейсу.</p>
<p>Пример использования:</p>
<pre><code class="language-java">public class ExampleService extends IntentService {

	public ExampleService() {
		super("ExampleService");
	}

	@Override
	protected void onHandleIntent(Intent intent) {
		doSomeShortWork();
	}
}
</code></pre>
<p><a href="https://wcoder.github.io/notes/android-threading-all-you-need-to-know-part2">Часть 2. 7 шаблонов использования многопоточности в Android</a></p>
<p><a href="https://www.toptal.com/android/android-threading-all-you-need-to-know" name="original">Оригинал</a></p>
<p>Теги: <a href="/tags/#%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C">многопоточность</a>, <a href="/tags/#android">android</a>, <a href="/tags/#%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4">перевод</a></p>
<p class="edit-post-btn"> <!--noindex--><a href="https://github.com/wcoder/wcoder.github.io/edit/master/_posts/2017-08-13-android-threading-all-you-need-to-know-part1.md" rel="nofollow" title="Редактировать страницу на GitHub">Редактировать</a><!--/noindex--></p>
<div class="share-btn"> <a class="btn-vk" data-id="vk" title="VK"><img alt="VK" width="16" src="/images/vk.svg"></a> <a class="btn-facebook" data-id="fb" title="Facebook"><img alt="Facebook" width="16" src="/images/facebook.svg"></a> <a class="btn-twitter" data-id="tw" title="Twitter"><img alt="Twitter" width="16" src="/images/twitter.svg"></a> <a class="btn-telegram" data-id="tg" title="Telegram"><img alt="Telegram" width="16" src="/images/telegram.svg"></a> <a class="btn-mail" data-id="mail" title="Email"><img alt="Email" width="16" src="/images/mail.svg"></a>
</div>
</div></article>
</div></div><hr><div class="wrapper"> <footer class="footer"><p class="copyrights"> © 2014–<span itemprop="copyrightYear">2025</span></p>
<p xmlns:cc="http://creativecommons.org/ns#" class="license"> <a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" title="This work is licensed under CC BY-SA 4.0"> <img style="height:20px!important;" src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" alt="CC BY-SA 4.0"> </a></p></footer>
</div><script src="/js/highlight.pack.js"></script> <script src="/js/highlightjs-line-numbers.min.js"></script> <script> hljs.initHighlightingOnLoad(); hljs.initLineNumbersOnLoad(); </script> <script src="/js/share-buttons.js"></script> <!--Generated with Jekyll at Nov. 11, 2025 11:59:43 AM (+03)--> </body> </html>
